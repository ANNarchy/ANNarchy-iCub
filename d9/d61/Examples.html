<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ANNarchy iCub Interface: Basic Python Examples</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ANNarchy iCub Interface
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d9/d61/Examples.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Basic Python Examples </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_Examples"></a> </p>
<h1><a class="anchor" id="autotoc_md8"></a>
Main Module Handling</h1>
<p>The first steps are equal for all interface modules. These are the instantiation of the main wrapper (ANNiCub_wrapper class), that is needed exactly once. </p><div class="fragment"><div class="line">import ANN_iCub_Interface as ann_icub</div>
<div class="line">import ANN_iCub_Interface.iCub as icub_int</div>
<div class="line"> </div>
<div class="line"># Interface main wrapper, is needed once</div>
<div class="line">iCub = icub_int.iCub_Interface.ANNiCub_wrapper()</div>
</div><!-- fragment --><p> After creating this instance the respective modules can be created. For this two alternatives are currently possible and can also be combined. The first option is the instanciation on the individual module level, that is described in the respective module sections. The second opportunity is to create multiple modules at once based on a configuration given in a XML-config file. This config-file is further explained in the Manual-&gt;Configuration section.</p>
<div class="fragment"><div class="line"># Interface initialization from XML-file</div>
<div class="line">ret_val, robot_dict = ann_icub.init_robot_from_file(iCub, &quot;./data/demo_robot.xml&quot;)</div>
<div class="line">if not ret_val:</div>
<div class="line">    sys.exit(&quot;Interface initialization failed!&quot;)</div>
</div><!-- fragment --><p> The inidivual instance can then be acquired from the wrapper:</p>
<div class="fragment"><div class="line"># Joint Reader</div>
<div class="line">rarm_jreader = iCub.get_jreader_by_part(&quot;PART_KEY&quot;) # or</div>
<div class="line">rarm_jreader = iCub.get_jreader_by_name(&quot;JR_name&quot;)</div>
<div class="line"> </div>
<div class="line"># Joint Writer</div>
<div class="line">rarm_jwriter = iCub.get_jwriter_by_part(&quot;PART_KEY&quot;) # or</div>
<div class="line">rarm_jwriter = iCub.get_jwriter_by_name(&quot;JW_name&quot;)</div>
<div class="line"> </div>
<div class="line"># Skin Reader</div>
<div class="line">rarm_sreader = iCub.get_skinreader_by_name(&quot;SR_name&quot;)</div>
<div class="line"> </div>
<div class="line"># Visual Reader</div>
<div class="line">vreader = iCub.get_vis_reader_by_name(&quot;VR_name&quot;)</div>
<div class="line"> </div>
<div class="line"># Kinematic Reader</div>
<div class="line">kinread = iCub.get_kin_reader_by_name(&quot;KR_name&quot;)</div>
<div class="line"> </div>
<div class="line"># Kinematic Writer</div>
<div class="line">kinwrite = iCub.get_kin_writer_by_name(&quot;KW_name&quot;)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md9"></a>
Joint Reader</h1>
<p>In case the module is handled indiviually, the first step is the creation and initialization of the Joint Reader module: </p><div class="fragment"><div class="line"># Add joint reader instances</div>
<div class="line">jreader = Joint_Reader.PyJointReader()</div>
<div class="line"> </div>
<div class="line"># Init interface instances</div>
<div class="line">if not jreader.init(iCub, &quot;name_reader&quot;, iCub_Const.PART_KEY_HEAD, 0.5, 15, ini_path=params.INTERFACE_INI_PATH):</div>
<div class="line">    sys.exit(&quot;Initialization failed!&quot;)</div>
</div><!-- fragment --><p>The joint angles can be read in two different formats (explicit degree values or gaussian population code) and from single, multiple or all joints at the same time. For the explicit values the following set of methods: </p><div class="fragment"><div class="line">joint_angle = jreader.read_double_one(joint=0) # angle only for joint 0; shape: single values</div>
<div class="line">joint_angles = jreader.read_double_multiple(joints=[0,1,3]) # angles for joints 0,1,3; shape [#joint_selection]</div>
<div class="line">joint_angles = jreader.read_double_all() # angles for all joints; shape [#joints_robot_part]</div>
</div><!-- fragment --><p>For population-coded values the following set of methods: </p><div class="fragment"><div class="line">joint_angle_coded = jreader.read_pop_one(joint=0) # angle only for joint 0; shape: [pop size defined by n_pop or degr_per_neuron]</div>
<div class="line">joint_angles_coded = jreader.read_pop_multiple(joints=[0,1,3]) # angles for joints 0,1,3; shape [#joint_selection, pop size defined by n_pop or degr_per_neuron]</div>
<div class="line">joint_angles_coded = jreader.read_pop_all() # angles for all joints; shape [#joints_robot_part, pop size defined by n_pop or degr_per_neuron]</div>
</div><!-- fragment --><p>For information about the configuration several getter methods are provided: </p><div class="fragment"><div class="line">jreader.get_joint_count() # number of joints controlled by the robot part</div>
<div class="line">jreader.get_joints_deg_res() # resolution of the population code -&gt; one neuron represents XX.YY°; shape [#joints_robot_part]</div>
<div class="line">jreader.get_neurons_per_joint() # size of the population representing the full joint range in population code; shape [#joints_robot_part]</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md10"></a>
Joint Writer</h1>
<p>In case the module is handled indiviually, the first step is the creation and initialization of the Joint Writer module: </p><div class="fragment"><div class="line"># Add joint writer instances</div>
<div class="line">jwriter = Joint_Writer.PyJointWriter()</div>
<div class="line"> </div>
<div class="line"># Init interface instances</div>
<div class="line">if not jwriter.init(iCub, &quot;name_writer&quot;, iCub_Const.PART_KEY_HEAD, 0.5, 15, ini_path=params.INTERFACE_INI_PATH):</div>
<div class="line">    sys.exit(&quot;Initialization failed!&quot;)</div>
</div><!-- fragment --><p>To configure the motion properties like acceleration use the specific setter methods: </p><div class="fragment"><div class="line"># For all methods the joint selection (parameter &quot;joint&quot;) is either single specific joint (joint id: e.g. 0) or set the same value for all joints with id: -1 </div>
<div class="line">jwriter.set_joint_controlmode(control_mode, joint) # control_mode: &quot;position&quot;/&quot;velocity&quot;, default &quot;position&quot;</div>
<div class="line">jwriter.set_joint_acceleration(acc, joint) # acc: joint acceleration</div>
<div class="line">jwriter.set_joint_velocity(speed, joint) # speed: joint velocity</div>
</div><!-- fragment --><p>The Joint Writer follows the same schema as the Joint Reader, providing methods to control the robot joints either with explicit degree values or population-coded values. For the explicit values the following set of methods: </p><div class="fragment"><div class="line"># general parameter: joint_angles in degree or velocity; mode: &quot;abs&quot;/&quot;rel&quot;/&quot;vel&quot; -&gt; absolute/relative/velocity; blocking True/False -&gt; wait for motion execution; timeout -&gt; stop waiting for motion</div>
<div class="line">jwriter.write_double_one(joint_angle, joint, mode, blocking, timeout) # joint -&gt; selected joint e.g. 0</div>
<div class="line">jwriter.write_double_multiple(joint_angles, joints, mode, blocking, timeout) # joint selection, e.g. [1,2,4]</div>
<div class="line">jwriter.write_double_all(joint_angles, mode, blocking, timeout) </div>
</div><!-- fragment --><p>For population-coded values the following set of methods: </p><div class="fragment"><div class="line"># general parameter: joint_angles in population code; mode: &quot;abs&quot;/&quot;rel&quot; -&gt; absolute/relative; blocking True/False -&gt; wait for motion execution; timeout -&gt; stop waiting for motion</div>
<div class="line">jwriter.write_pop_one(joint_angle, joint, mode, blocking, timeout) # joint_angle shape: [pop_size]; joint -&gt; selected joint e.g. 0</div>
<div class="line">jwriter.write_pop_multiple(joint_angles, joints, mode, blocking, timeout) # joint_angles shape: [#joint_selection, pop_size] # joint selection, e.g. [1,2,4]</div>
<div class="line">jwriter.write_pop_all(joint_angles, mode, blocking, timeout) # joint_angles shape: [#joints_robot_part, pop_size] </div>
</div><!-- fragment --><p>For information about the configuration several getter methods are provided: </p><div class="fragment"><div class="line">jwriter.get_joint_count() # number of joints controlled by the robot part</div>
<div class="line">jwriter.get_joints_deg_res() # resolution of the population code -&gt; one neuron represents XX.YY°; shape [#joints_robot_part]</div>
<div class="line">jwriter.get_neurons_per_joint() # size of the population representing the full joint range in population code; shape [#joints_robot_part]</div>
<div class="line">jwriter.get_joint_limits() # return joint working range for all joints controlled by the writer; shape [#joints_robot_part, 2]; format: [joint, 0: max/1: min]</div>
<div class="line">jwriter.get_joint_limits_max() # return the joints maximum possible values for each joint in the robot part; shape [#joints_robot_part]</div>
<div class="line">jwriter.get_joint_limits_min() # return the joints minimum possible values for each joint in the robot part; shape [#joints_robot_part]</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md11"></a>
Visual Reader</h1>
<p>In case the module is handled indiviually, the first step is the creation and initialization of the Visual Reader module: </p><div class="fragment"><div class="line"># Add visual reader instances</div>
<div class="line">visreader = Visual_Reader.PyVisualReader()</div>
<div class="line"> </div>
<div class="line"># Init interface instances</div>
<div class="line">if not visreader.init(iCub, &quot;name_reader&quot;, &#39;r&#39;, ini_path=params.INTERFACE_INI_PATH):</div>
<div class="line">    sys.exit(&quot;Initialization failed!&quot;)</div>
</div><!-- fragment --><p>For the image retrieval from the robot currently two methods exists: First Method: The images from the iCub are preprocessed (normalization [0., 1.] and either RGB or grayscale images) and dependent on the configuration the left, right or both images are retrieved. For the images of both eyes only one reader module is necessary. </p><div class="fragment"><div class="line"># grayscale/RGB images (dependent on INI-file parameter); preprocessed -&gt; range [0., 1.]</div>
<div class="line">imgs = visreader.read_robot_eyes()</div>
<div class="line">imgs = test_imgs.reshape(2, 240, 320) # both eye images are retrieved</div>
<div class="line"> </div>
<div class="line">imgright = imgs[0] # right eye image</div>
<div class="line">imgleft = imgs[1] # left eye image</div>
</div><!-- fragment --><p>Second Method: The raw images are retrieved from the iCub. The images are in RGB-colors and in the value range is [0, 255]. For the images of both eyes only two reader modules are necessary. </p><div class="fragment"><div class="line"># RGB images; no preprocessing -&gt; range [0, 255]</div>
<div class="line">imgright = np.array(visreader_r.retrieve_robot_eye()).reshape(240, 320, 3)</div>
<div class="line">imgleft = np.array(visreader_l.retrieve_robot_eye()).reshape(240, 320, 3)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md12"></a>
Skin Reader</h1>
<p>In case the module is handled indiviually, the first step is the creation and initialization of the Skin Reader module: </p><div class="fragment"><div class="line"># Add skin reader instance</div>
<div class="line">sreader = Skin_Reader.PySkinReader()</div>
<div class="line"> </div>
<div class="line"># Init interface instances</div>
<div class="line">if not sreader.init(iCub, &quot;skin_right&quot;, &quot;r&quot;, True, ini_path=params.INTERFACE_INI_PATH):</div>
<div class="line">    sys.exit(&quot;Initialization failed!&quot;)</div>
</div><!-- fragment --><p>At this point the skin reader only handles the skin/tactile sensors at the iCub arms. To read the data from the sensors two the skin reader offers two different ways: The first option is to directly receive the sensor data from the different arm sections: </p><div class="fragment"><div class="line"># Read skin sensor data -&gt; skin section specific</div>
<div class="line">print(&quot;Data arm:&quot;) # upper arm</div>
<div class="line">print(sreader.read_skin_arm())</div>
<div class="line"> </div>
<div class="line">print(&quot;Data forearm:&quot;)</div>
<div class="line">print(sreader.read_skin_forearm())</div>
<div class="line"> </div>
<div class="line">print(&quot;Data hand:&quot;)</div>
<div class="line">print(sreader.read_skin_hand())</div>
</div><!-- fragment --><p>In the second option the data is buffered inside the reader module and can be collected per part after the data acquisition: </p><div class="fragment"><div class="line"># Read skin sensor data -&gt; buffered</div>
<div class="line">for i in range(10):</div>
<div class="line">    # read tactile data</div>
<div class="line">    sreader.read_tactile()</div>
<div class="line"> </div>
<div class="line"># print tactile data</div>
<div class="line">print(&quot;Data arm:&quot;) # upper arm</div>
<div class="line">print(sreader.get_tactile_arm())</div>
<div class="line"> </div>
<div class="line">print(&quot;Data forearm:&quot;)</div>
<div class="line">print(sreader.get_tactile_forearm())</div>
<div class="line"> </div>
<div class="line">print(&quot;Data hand:&quot;)</div>
<div class="line">print(sreader.get_tactile_hand())</div>
</div><!-- fragment --><p>To get information about the sensor count and therefore the vector size of the different data arrays the following getter-methods are provided: </p><div class="fragment"><div class="line">sreader.get_tactile_arm_size()</div>
<div class="line">sreader.get_tactile_forearm_size()</div>
<div class="line">sreader.get_tactile_hand_size()</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md13"></a>
Kinematic Reader</h1>
<p>In case the module is handled indiviually, the first step is the creation and initialization of the Kinematic Reader module: </p><div class="fragment"><div class="line"># Add kinematic reader instance</div>
<div class="line">kinreader = Kinematic_Reader.PyKinematicReader()</div>
<div class="line"> </div>
<div class="line"># Init kinematic reader</div>
<div class="line">if not kinreader.init(iCub, &quot;name_fkin&quot;, part=iCub_const.PART_KEY_RIGHT_ARM, version=2, ini_path=params.INTERFACE_INI_PATH, offline_mode=params.offline):</div>
<div class="line">    sys.exit(&quot;Initialization failed&quot;)</div>
</div><!-- fragment --><p>To get information about the current state of the kinematic chain several methods exists: </p><div class="fragment"><div class="line">print(&quot;DOF:&quot;, kinreader.get_DOF()) # complete degree of freedom (DOF) of the chain</div>
<div class="line">print(&quot;Active DOF:&quot;, kinreader.get_DOF_links()) # active links of the chain</div>
<div class="line">print(&quot;Blocked links:&quot;, kinreader.get_blocked_links()) # blocked links of the chain</div>
<div class="line">print(&quot;Current angles:&quot;, np.rad2deg(kinreader.get_jointangles())) # current joint angles of the active part of the kinematic chain</div>
</div><!-- fragment --><p>The forward kinematic is by default in an online mode, directly receiving the joint angles from the robot. But if the reader is configured to work in offline mode, no connection to the robot is established. Then the state of the kinematic chain need to be handled manually. This means the static links should be blocked and the joint angles of the active part has to be set in radians. Since all angles are initialized with zero, blocked links may need to be set once before blocking them.</p>
<div class="fragment"><div class="line"># Perform forward kinematic</div>
<div class="line">if params.offline:</div>
<div class="line">    kinreader.block_links([0, 1, 2]) # block torso links</div>
<div class="line">    joint_angles = np.deg2rad(np.array([15., 16., 0., 70., -90., 0., 0.]))</div>
<div class="line">    kinreader.set_jointangles(joint_angles)</div>
</div><!-- fragment --><p>Finally the forward kinematic can be performed, either for the end-effector (hand for the arms) or for a specific joint in the kinematic chain. The position is given in the robot reference frame. </p><div class="fragment"><div class="line"># print end-effector position</div>
<div class="line">end_eff_pos = kinreader.get_handposition()</div>
<div class="line">print(&quot;End-Effector&quot;, end_eff_pos)  # (robot reference frame)</div>
<div class="line">print(&quot;End-Effector&quot;, iTransform.transform_position(end_eff_pos, params.Transfermat_robot2world))  # (simulator reference frame)</div>
<div class="line"> </div>
<div class="line"># print position for specific joint of the kinematic chain</div>
<div class="line">joint3_pos = kinreader.get_jointposition(3)</div>
<div class="line">print(&quot;Joint 3&quot;, joint3_pos)    # (robot reference frame)</div>
<div class="line">print(&quot;Joint 3&quot;, iTransform.transform_position(joint3_pos, params.Transfermat_robot2world))    # (simulator reference frame)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md14"></a>
Kinematic Writer</h1>
<p>In case the module is handled indiviually, the first step is the creation and initialization of the Kinematic Reader module: </p><div class="fragment"><div class="line"># Add kinematic writer instance</div>
<div class="line">kinwriter = Kinematic_Writer.PyKinematicWriter()</div>
<div class="line"> </div>
<div class="line"># Init kinematic writer</div>
<div class="line">if not kinwriter.init(iCub, &quot;invkin&quot;, part=iCub_Const.PART_KEY_RIGHT_ARM, version=2, ini_path=params.INTERFACE_INI_PATH, offline_mode=params.offline):</div>
<div class="line">    sys.exit(&quot;Initialization failed&quot;)</div>
</div><!-- fragment --><p>To get information about the current state of the kinematic chain several methods exists: </p><div class="fragment"><div class="line">print(&quot;DOF:&quot;, kinwriter.get_DOF()) # complete degree of freedom (DOF) of the chain</div>
<div class="line">print(&quot;Active DOF:&quot;, kinwriter.get_DOF_links()) # active links of the chain</div>
<div class="line">print(&quot;Blocked links:&quot;, kinwriter.get_blocked_links()) # blocked links of the chain</div>
<div class="line">print(&quot;Current angles:&quot;, np.rad2deg(kinwriter.get_jointangles())) # current joint angles of the active part of the kinematic chain</div>
</div><!-- fragment --><p>The inverse kinematic is by default in an online mode, directly receiving the joint angles from the robot. But if the writer is configured to work in offline mode, no connection to the robot is established. Then the state of the kinematic chain need to be handled manually. This means the static links should be blocked and the joint angles of the active part has to be set in radians. Since all angles are initialized with zero, blocked links may need to be set once before blocking them. Finally the inverse kinematic can be performed depended on online or offline mode: </p><div class="fragment"><div class="line">if params.offline:</div>
<div class="line">    # block links and set starting angles manually</div>
<div class="line">    kinwriter.block_links(blocked_joints)</div>
<div class="line">    kinwriter.set_jointangles(joint_angles)</div>
<div class="line">    # perform inverse kinematics for given target</div>
<div class="line">    joint_angles = kinwriter.solve_InvKin(target_position)</div>
<div class="line">else:</div>
<div class="line">    # define blocked/static links; current angles are retrieved from the robot and perform inverse kinematics for given target</div>
<div class="line">    joint_angles = kinwriter.solve_InvKin(target_position, blocked_joints)</div>
<div class="line">print(&quot;Estimated joint angles:&quot;, np.rad2deg(joint_angles))</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md15"></a>
Final Wrap-up</h1>
<p>To clean up at the end, each module is equipped with a close-method. These can be called for all in one from the main wrapper with the clear method to clean up all initialized modules.</p>
<div class="fragment"><div class="line"># Either close module seperately or</div>
<div class="line">module.close(iCub)</div>
<div class="line"> </div>
<div class="line"># Close all interface instances in one step</div>
<div class="line">print(&#39;----- Close interface instances -----&#39;)</div>
<div class="line">iCub.clear()</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
